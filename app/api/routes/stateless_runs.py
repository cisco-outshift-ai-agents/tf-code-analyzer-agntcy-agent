# generated by fastapi-codegen:
#   filename:  openapi.json

from __future__ import annotations

import logging

from fastapi import APIRouter, HTTPException, Response, status
from fastapi.responses import JSONResponse
from app.models.models import Any, ErrorResponse, RunCreateStateless, Union
from app.graph.graph import StaticAnalyzerWorkflow
from app.core.config import get_llm_chain


router = APIRouter(tags=["Stateless Runs"])
logger = logging.getLogger(__name__)  # This will be "app.api.routes.<name>"
workflow = StaticAnalyzerWorkflow(chain = get_llm_chain())

# TODO: change response_model to appropriate type
@router.post(
    "/runs",
    response_model=Any,
    responses={
        "404": {"model": ErrorResponse},
        "409": {"model": ErrorResponse},
        "422": {"model": ErrorResponse},
    },
    tags=["Stateless Runs"],
)
def run_stateless_runs_post(body: RunCreateStateless) -> Union[Any, ErrorResponse]:
    """
    Create Background Run
    """
    try:
        #TODO: modify the input and output based on decision for communication between agents

        # -----------------------------------------------
        # Extract the file path to the Terraform files from the payload.
        # We expect the content to be located at: payload["input"]["file_path"]
        # -----------------------------------------------

        # Retrieve the 'input' field and ensure it is a dictionary.
        input_field = body.input
        if not isinstance(input_field, dict):
            raise ValueError("The 'input' field should be a dictionary.")

        # Retrieve the 'file_path' field from the input dictionary.
        file_path = input_field.get("file_path")

        # Ensure that the 'file_path' field is a string.
        if not isinstance(file_path, str):
            raise ValueError("The 'file_path' field should be a string.")
        
        result = workflow.analyze(file_path)
    except HTTPException as http_exc:
        # Log HTTP exceptions and re-raise them so that FastAPI can generate the appropriate response.
        logger.error("HTTP error during run processing: %s", http_exc.detail)
        raise http_exc
    except Exception as exc:
        logger.error("Error during run processing: %s", exc)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=exc,
        )

    return JSONResponse(content=result, status_code=status.HTTP_200_OK)

@router.post(
    "/runs/stream",
    response_model=str,
    responses={
        "404": {"model": ErrorResponse},
        "409": {"model": ErrorResponse},
        "422": {"model": ErrorResponse},
    },
    tags=["Stateless Runs"],
)
def stream_run_stateless_runs_stream_post(
    body: RunCreateStateless,
) -> Union[str, ErrorResponse]:
    """
    Create Run, Stream Output
    """
    pass


@router.post(
    "/runs/wait",
    response_model=Any,
    responses={
        "404": {"model": ErrorResponse},
        "409": {"model": ErrorResponse},
        "422": {"model": ErrorResponse},
    },
    tags=["Stateless Runs"],
)
def wait_run_stateless_runs_wait_post(
    body: RunCreateStateless,
) -> Union[Any, ErrorResponse]:
    """
    Create Run, Wait for Output
    """
    pass
